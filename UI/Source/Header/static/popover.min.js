// ref: https://github.com/oddbird/popover-polyfill
// https://unpkg.com/@oddbird/popover-polyfill@0.6.0/dist/popover.min.js
var d = class extends Event { oldState; newState; constructor(t, { oldState: o = "", newState: r = "", ...i } = {}) { super(t, i), this.oldState = String(o || ""), this.newState = String(r || "") } }, B = new WeakMap; function A(e, t, o) { B.set(e, setTimeout(() => { B.has(e) && e.dispatchEvent(new d("toggle", { cancelable: !1, oldState: t, newState: o })) }, 0)) } var O = globalThis.ShadowRoot || function () { }, _ = globalThis.HTMLDialogElement || function () { }, b = new WeakMap, f = new WeakMap, u = new WeakMap, v = new WeakMap; function y(e) { return v.get(e) || "hidden" } var H = new WeakMap; function M(e) { return [...e].pop() } function z(e) { let t = e.popoverTargetElement; if (!(t instanceof HTMLElement)) return; let o = y(t); e.popoverTargetAction === "show" && o === "showing" || e.popoverTargetAction === "hide" && o === "hidden" || (o === "showing" ? E(t, !0, !0) : g(t, !1) && (H.set(t, e), k(t))) } function g(e, t) { return !(e.popover !== "auto" && e.popover !== "manual" && e.popover !== "hint" || !e.isConnected || t && y(e) !== "showing" || !t && y(e) !== "hidden" || e instanceof _ && e.hasAttribute("open") || document.fullscreenElement === e) } function C(e) { if (!e) return 0; let t = f.get(document) || new Set, o = u.get(document) || new Set; return o.has(e) ? [...o].indexOf(e) + t.size + 1 : t.has(e) ? [...t].indexOf(e) + 1 : 0 } function J(e) { let t = K(e), o = X(e); return C(t) > C(o) ? t : o } function S(e) { let t, o = u.get(e) || new Set, r = f.get(e) || new Set, i = o.size > 0 ? o : r.size > 0 ? r : null; return i ? (t = M(i), t.isConnected ? t : (i.delete(t), S(e))) : null } function W(e) { for (let t of e || []) if (!t.isConnected) e.delete(t); else return t; return null } function m(e) { return typeof e.getRootNode == "function" ? e.getRootNode() : e.parentNode ? m(e.parentNode) : e } function K(e) { for (; e;) { if (e instanceof HTMLElement && e.popover === "auto" && v.get(e) === "showing") return e; if (e = e instanceof Element && e.assignedSlot || e.parentElement || m(e), e instanceof O && (e = e.host), e instanceof Document) return } } function X(e) { for (; e;) { let t = e.popoverTargetElement; if (t instanceof HTMLElement) return t; if (e = e.parentElement || m(e), e instanceof O && (e = e.host), e instanceof Document) return } } function q(e, t) { let o = new Map, r = 0; for (let l of t || []) o.set(l, r), r += 1; o.set(e, r), r += 1; let i = null; function a(l) { if (!l) return; let p = !1, n = null, s = null; for (; !p;) { if (n = K(l) || null, n === null || !o.has(n)) return; (e.popover === "hint" || n.popover === "auto") && (p = !0), p || (l = n.parentElement) } s = o.get(n), (i === null || o.get(i) < s) && (i = n) } return a(e.parentElement || m(e)), i } function Y(e) { return e.hidden || e instanceof O || (e instanceof HTMLButtonElement || e instanceof HTMLInputElement || e instanceof HTMLSelectElement || e instanceof HTMLTextAreaElement || e instanceof HTMLOptGroupElement || e instanceof HTMLOptionElement || e instanceof HTMLFieldSetElement) && e.disabled || e instanceof HTMLInputElement && e.type === "hidden" || e instanceof HTMLAnchorElement && e.href === "" ? !1 : typeof e.tabIndex == "number" && e.tabIndex !== -1 } function Z(e) { if (e.shadowRoot && e.shadowRoot.delegatesFocus !== !0) return null; let t = e; t.shadowRoot && (t = t.shadowRoot); let o = t.querySelector("[autofocus]"); if (o) return o; { let a = t.querySelectorAll("slot"); for (let l of a) { let p = l.assignedElements({ flatten: !0 }); for (let n of p) { if (n.hasAttribute("autofocus")) return n; if (o = n.querySelector("[autofocus]"), o) return o } } } let r = e.ownerDocument.createTreeWalker(t, NodeFilter.SHOW_ELEMENT), i = r.currentNode; for (; i;) { if (Y(i)) return i; i = r.nextNode() } } function ee(e) { Z(e)?.focus() } var P = new WeakMap; function k(e) { if (!g(e, !1)) return; let t = e.ownerDocument; if (!e.dispatchEvent(new d("beforetoggle", { cancelable: !0, oldState: "closed", newState: "open" })) || !g(e, !1)) return; let o = !1, r = e.popover, i = null, a = q(e, f.get(t) || new Set), l = q(e, u.get(t) || new Set); if (r === "auto" && (I(u.get(t) || new Set, o, !0), h(a || t, o, !0), i = "auto"), r === "hint" && (l ? (h(l, o, !0), i = "hint") : (I(u.get(t) || new Set, o, !0), a ? (h(a, o, !0), i = "auto") : i = "hint")), r === "auto" || r === "hint") { if (r !== e.popover || !g(e, !1)) return; S(t) || (o = !0), i === "auto" ? (f.has(t) || f.set(t, new Set), f.get(t).add(e)) : i === "hint" && (u.has(t) || u.set(t, new Set), u.get(t).add(e)) } P.delete(e); let p = t.activeElement; e.classList.add(":popover-open"), v.set(e, "showing"), b.has(t) || b.set(t, new Set), b.get(t).add(e), V(H.get(e), !0), ee(e), o && p && e.popover === "auto" && P.set(e, p), A(e, "closed", "open") } function E(e, t = !1, o = !1) { if (!g(e, !0)) return; let r = e.ownerDocument; if (["auto", "hint"].includes(e.popover) && (h(e, t, o), !g(e, !0))) return; let i = f.get(r) || new Set, a = i.has(e) && M(i) === e; if (V(H.get(e), !1), H.delete(e), o && (e.dispatchEvent(new d("beforetoggle", { oldState: "open", newState: "closed" })), a && M(i) !== e && h(e, t, o), !g(e, !0))) return; b.get(r)?.delete(e), i.delete(e), u.get(r)?.delete(e), e.classList.remove(":popover-open"), v.set(e, "hidden"), o && A(e, "open", "closed"); let l = P.get(e); l && (P.delete(e), t && l.focus()) } function te(e, t = !1, o = !1) { let r = S(e); for (; r;)E(r, t, o), r = S(e) } function I(e, t = !1, o = !1) { let r = W(e); for (; r;)E(r, t, o), r = W(e) } function j(e, t, o, r) { let i = !1, a = !1; for (; i || !a;) { a = !0; let l = null, p = !1; for (let n of t) if (n === e) p = !0; else if (p) { l = n; break } if (!l) return; for (; y(l) === "showing" && t.size;)E(M(t), o, r); t.has(e) && M(t) !== e && (i = !0), i && (r = !1) } } function h(e, t, o) { let r = e.ownerDocument || e; if (e instanceof Document) return te(r, t, o); if (u.get(r)?.has(e)) { j(e, u.get(r), t, o); return } I(u.get(r) || new Set, t, o), f.get(r)?.has(e) && j(e, f.get(r), t, o) } var x = new WeakMap; function R(e) { if (!e.isTrusted) return; let t = e.composedPath()[0]; if (!t) return; let o = t.ownerDocument; if (!S(o)) return; let i = J(t); if (i && e.type === "pointerdown") x.set(o, i); else if (e.type === "pointerup") { let a = x.get(o) === i; x.delete(o), a && h(i || o, !1, !0) } } var D = new WeakMap; function V(e, t = !1) { if (!e) return; D.has(e) || D.set(e, e.getAttribute("aria-expanded")); let o = e.popoverTargetElement; if (o instanceof HTMLElement && o.popover === "auto") e.setAttribute("aria-expanded", String(t)); else { let r = D.get(e); r ? e.setAttribute("aria-expanded", r) : e.removeAttribute("aria-expanded") } } var U = globalThis.ShadowRoot || function () { }; function $() { return typeof HTMLElement < "u" && typeof HTMLElement.prototype == "object" && "popover" in HTMLElement.prototype } function w(e, t, o) { let r = e[t]; Object.defineProperty(e, t, { value(i) { return r.call(this, o(i)) } }) } var oe = /(^|[^\\]):popover-open\b/g; function ne() { return typeof globalThis.CSSLayerBlockRule == "function" } function re() {
	let e = ne(); return `
${e ? "@layer popover-polyfill {" : ""}
  :where([popover]) {
    position: fixed;
    z-index: 2147483647;
    inset: 0;
    padding: 0.25em;
    width: fit-content;
    height: fit-content;
    border-width: initial;
    border-color: initial;
    border-image: initial;
    border-style: solid;
    background-color: canvas;
    color: canvastext;
    overflow: auto;
    margin: auto;
  }

  :where([popover]:not(.\\:popover-open)) {
    display: none;
  }

  :where(dialog[popover].\\:popover-open) {
    display: block;
  }

  :where(dialog[popover][open]) {
    display: revert;
  }

  :where([anchor].\\:popover-open) {
    inset: auto;
  }

  :where([anchor]:popover-open) {
    inset: auto;
  }

  @supports not (background-color: canvas) {
    :where([popover]) {
      background-color: white;
      color: black;
    }
  }

  @supports (width: -moz-fit-content) {
    :where([popover]) {
      width: -moz-fit-content;
      height: -moz-fit-content;
    }
  }

  @supports not (inset: 0) {
    :where([popover]) {
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }
  }
${e ? "}" : ""}
`} var T = null; function N(e) { let t = re(); if (T === null) try { T = new CSSStyleSheet, T.replaceSync(t) } catch { T = !1 } if (T === !1) { let o = document.createElement("style"); o.textContent = t, e instanceof Document ? e.head.prepend(o) : e.prepend(o) } else e.adoptedStyleSheets = [T, ...e.adoptedStyleSheets] } function G() { if (typeof window > "u") return; window.ToggleEvent = window.ToggleEvent || d; function e(n) { return n?.includes(":popover-open") && (n = n.replace(oe, "$1.\\:popover-open")), n } w(Document.prototype, "querySelector", e), w(Document.prototype, "querySelectorAll", e), w(Element.prototype, "querySelector", e), w(Element.prototype, "querySelectorAll", e), w(Element.prototype, "matches", e), w(Element.prototype, "closest", e), w(DocumentFragment.prototype, "querySelectorAll", e), Object.defineProperties(HTMLElement.prototype, { popover: { enumerable: !0, configurable: !0, get() { if (!this.hasAttribute("popover")) return null; let n = (this.getAttribute("popover") || "").toLowerCase(); return n === "" || n == "auto" ? "auto" : n == "hint" ? "hint" : "manual" }, set(n) { n === null ? this.removeAttribute("popover") : this.setAttribute("popover", n) } }, showPopover: { enumerable: !0, configurable: !0, value(n = {}) { k(this) } }, hidePopover: { enumerable: !0, configurable: !0, value() { E(this, !0, !0) } }, togglePopover: { enumerable: !0, configurable: !0, value(n = {}) { return typeof n == "boolean" && (n = { force: n }), v.get(this) === "showing" && n.force === void 0 || n.force === !1 ? E(this, !0, !0) : (n.force === void 0 || n.force === !0) && k(this), v.get(this) === "showing" } } }); let t = Element.prototype.attachShadow; t && Object.defineProperties(Element.prototype, { attachShadow: { enumerable: !0, configurable: !0, writable: !0, value(n) { let s = t.call(this, n); return N(s), s } } }); let o = HTMLElement.prototype.attachInternals; o && Object.defineProperties(HTMLElement.prototype, { attachInternals: { enumerable: !0, configurable: !0, writable: !0, value() { let n = o.call(this); return n.shadowRoot && N(n.shadowRoot), n } } }); let r = new WeakMap; function i(n) { Object.defineProperties(n.prototype, { popoverTargetElement: { enumerable: !0, configurable: !0, set(s) { if (s === null) this.removeAttribute("popovertarget"), r.delete(this); else if (s instanceof Element) this.setAttribute("popovertarget", ""), r.set(this, s); else throw new TypeError("popoverTargetElement must be an element or null") }, get() { if (this.localName !== "button" && this.localName !== "input" || this.localName === "input" && this.type !== "reset" && this.type !== "image" && this.type !== "button" || this.disabled || this.form && this.type === "submit") return null; let s = r.get(this); if (s && s.isConnected) return s; if (s && !s.isConnected) return r.delete(this), null; let c = m(this), L = this.getAttribute("popovertarget"); return (c instanceof Document || c instanceof U) && L && c.getElementById(L) || null } }, popoverTargetAction: { enumerable: !0, configurable: !0, get() { let s = (this.getAttribute("popovertargetaction") || "").toLowerCase(); return s === "show" || s === "hide" ? s : "toggle" }, set(s) { this.setAttribute("popovertargetaction", s) } } }) } i(HTMLButtonElement), i(HTMLInputElement); let a = n => { let s = n.composedPath(), c = s[0]; if (!(c instanceof Element) || c?.shadowRoot) return; let L = m(c); if (!(L instanceof U || L instanceof Document)) return; let F = s.find(Q => Q.matches?.("[popovertargetaction],[popovertarget]")); if (F) { z(F), n.preventDefault(); return } }, l = n => { let s = n.key, c = n.target; !n.defaultPrevented && c && (s === "Escape" || s === "Esc") && h(c.ownerDocument, !0, !0) }; (n => { n.addEventListener("click", a), n.addEventListener("keydown", l), n.addEventListener("pointerdown", R), n.addEventListener("pointerup", R) })(document), N(document) } $() || G();
//# sourceMappingURL=popover.min.js.map